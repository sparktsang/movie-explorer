<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wikidata Movie Explorer (Ultimate)</title>
    <!-- SheetJS for Excel Export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        body { font-family: -apple-system, sans-serif; padding: 20px; max-width: 1400px; margin: 0 auto; background: #1a1a1a; color: #eee; }
        h1 { text-align: center; color: #fff; }
        
        .controls { background: #2a2a2a; padding: 20px; border-radius: 8px; border: 1px solid #333; display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; margin-bottom: 20px; }
        .control-group { display: flex; flex-direction: column; }
        label { font-size: 0.8rem; font-weight: bold; margin-bottom: 5px; color: #bbb; }
        select, input { padding: 8px; border: 1px solid #444; border-radius: 4px; font-size: 1rem; background: #333; color: white; }
        
        .btn-row { display: flex; gap: 10px; margin-top: auto; }

        button { padding: 10px 20px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; transition: background 0.2s; color: white; }
        .btn-search { background: #0066cc; }
        .btn-search:hover { background: #004499; }
        .btn-download { background: #2e7d32; display: none; } /* Hidden by default */
        .btn-download:hover { background: #1b5e20; }
        button:disabled { background: #555; cursor: wait; }

        .checkbox-group { display: flex; align-items: center; padding-bottom: 8px; }
        .checkbox-group input { width: 18px; height: 18px; margin-right: 8px; cursor: pointer; }
        .checkbox-group label { margin: 0; cursor: pointer; color: #ff5252; }

        #status { margin: 10px 0; font-weight: bold; color: #aaa; text-align: center; min-height: 20px; }

        table { width: 100%; border-collapse: collapse; background: #222; border-radius: 8px; overflow: hidden; font-size: 0.9rem; table-layout: fixed; }
        th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #333; vertical-align: middle; word-wrap: break-word; }
        th { background: #333; font-weight: bold; color: #ddd; }
        tr:hover { background: #2a2a2a; }
        
        .col-title { width: 25%; font-weight: 600; }
        .col-title a { color: #64b5f6; text-decoration: none; }
        .col-title a:hover { text-decoration: underline; }

        .col-year { width: 6%; }
        .col-country { width: 10%; }
        .col-lang { width: 10%; }
        .col-genre { width: 20%; font-size: 0.85em; color: #aaa; }
        .col-duration { width: 8%; }
        .col-score { width: 15%; font-weight: bold; }
        
        .score-val { color: #ff5252; text-decoration: none; border-bottom: 1px dotted #ff5252; } 
        .score-val:hover { color: #ff8a80; border-bottom: 1px solid #ff8a80; }
        
        .review-count { font-size: 0.95em; color: #888; font-weight: normal; margin-left: 5px; }

    </style>
</head>
<body>

    <h1>Wikidata Movie Explorer</h1>

    <div class="controls">
        <div class="control-group">
            <label>From Year</label>
            <input type="number" id="year-start" value="2005" style="width: 80px;">
        </div>
        <div class="control-group">
            <label>To Year</label>
            <input type="number" id="year-end" value="2025" style="width: 80px;">
        </div>
        
        <div class="control-group">
            <label>Genre</label>
            <select id="genre">
                <option value="">(Any)</option>
                <option value="Q188473">Action</option>
                <option value="Q319221">Adventure</option>
                <option value="Q2447078">Alien Invasion</option>
                <option value="Q202866">Animated</option>
                <option value="Q47009776">Apocalyptic</option>
                <option value="Q645928">Biographical</option>
                <option value="Q5778924">Black Comedy</option>
                <option value="Q102260466">Body Horror</option>
                <option value="Q157443">Comedy</option>
                <option value="Q102429885">Coming-of-age</option>
                <option value="Q959790">Crime</option>
                <option value="Q846544">Disaster</option>
                <option value="Q93204">Documentary</option>
                <option value="Q130232">Drama</option>
                <option value="Q20443008">Dystopian</option>
                <option value="Q652256">Epic</option>
                <option value="Q599558">Erotic</option>
                <option value="Q1361932">Family</option>
                <option value="Q157394">Fantasy</option>
                <option value="Q200092">Horror</option>
                <option value="Q1033891">Martial Arts</option>
                <option value="Q842256">Musical</option>
                <option value="Q1200678">Mystery</option>
                <option value="Q20737414">Philosophical Fiction</option>
                <option value="Q2973201">Political</option>
                <option value="Q590103">Psychological Thriller</option>
                <option value="Q1054574">Romance</option>
                <option value="Q471839">Sci-Fi</option> 
                <option value="Q2973181">Speculative Fiction</option>
                <option value="Q2297927">Spy</option>
                <option value="Q1535153">Superhero</option>
                <option value="Q15898171">Survival</option>
                <option value="Q580850">Techno-thriller</option>
                <option value="Q2484376">Thriller</option>
                <option value="Q104765957">Time-travel</option>
                <option value="Q369747">War</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Country</label>
            <select id="country">
                <option value="">(Any)</option>
                <option value="Q30">USA</option>
                <option value="Q145">UK</option>
                <option value="Q17">Japan</option>
                <option value="Q884">South Korea</option>
                <option value="Q865">Taiwan</option>
                <option value="Q8646">Hong Kong</option>
                <option value="Q148">China</option>
                <option value="Q142">France</option>
                <option value="Q183">Germany</option>
                <option value="Q668">India</option>
            </select>
        </div>
        
        <div class="control-group">
            <div class="checkbox-group">
                <input type="checkbox" id="sort-rt">
                <label for="sort-rt">Sort by Tomatometer<br><span style="font-size:0.75em; color:#888; font-weight:normal;">(Only shows rated movies)</span></label>
            </div>
        </div>

        <div class="btn-row">
            <button onclick="fetchData()" class="btn-search" id="search-btn">Search Movies</button>
            <button onclick="downloadExcel()" class="btn-download" id="download-btn">Download Excel</button>
        </div>
    </div>

    <div id="status">Ready to search.</div>

    <table id="results-table">
        <thead>
            <tr>
                <th class="col-title">Title</th>
                <th class="col-year">Year</th>
                <th class="col-country">Country</th>
                <th class="col-lang">Language</th>
                <th class="col-genre">Genre</th>
                <th class="col-duration">Duration</th>
                <th class="col-score">Tomatometer</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script>
        const ENDPOINT = "https://query.wikidata.org/sparql";
        
        // Store processed data globally for export
        let globalMovieData = [];

        async function fetchData() {
            const btnSearch = document.getElementById('search-btn');
            const btnDownload = document.getElementById('download-btn');
            const status = document.getElementById('status');
            const tbody = document.querySelector("#results-table tbody");
            
            btnSearch.disabled = true;
            btnDownload.style.display = 'none'; // Hide download until success
            status.innerText = "Querying Wikidata... Please wait.";
            tbody.innerHTML = "";
            globalMovieData = []; // Clear old data

            const yStart = document.getElementById('year-start').value;
            const yEnd = document.getElementById('year-end').value;
            const genre = document.getElementById('genre').value;
            const country = document.getElementById('country').value;
            const sortByRT = document.getElementById('sort-rt').checked;

            const scoreBlock = `
                ?item p:P444 ?statement.
                ?statement ps:P444 ?rtScore;
                           pq:P447 wd:Q105584;     
                           pq:P459 wd:Q108403393.
                OPTIONAL { ?statement pq:P7887 ?reviewCount. }
            `;

            const scoreQuery = sortByRT ? scoreBlock : `OPTIONAL { ${scoreBlock} }`;

            const sparql = `
                SELECT DISTINCT 
                  ?item 
                  ?article 
                  ?minDate
                  (SAMPLE(?itemLabel) as ?title)
                  (GROUP_CONCAT(DISTINCT ?countryLabel; separator=", ") as ?countries)
                  (GROUP_CONCAT(DISTINCT ?langLabel; separator=", ") as ?languages)
                  (GROUP_CONCAT(DISTINCT ?genreLabel; separator=", ") as ?genres)
                  (SAMPLE(?duration) as ?runtime)
                  (SAMPLE(?rtScore) as ?score)
                  (SAMPLE(?reviewCount) as ?count)
                  (SAMPLE(?rtId) as ?rottenId)
                WHERE {
                  {
                    SELECT ?item (MIN(?pubDate) as ?minDate) WHERE {
                      ?item wdt:P31 wd:Q11424; wdt:P577 ?pubDate.
                      ${genre ? `?item wdt:P136 wd:${genre}.` : ''}
                      ${country ? `?item wdt:P495 wd:${country}.` : ''}
                    }
                    GROUP BY ?item
                  }
                  
                  FILTER((YEAR(?minDate)) >= ${yStart} && (YEAR(?minDate)) <= ${yEnd})

                  OPTIONAL { ?item wdt:P495 ?country. }
                  OPTIONAL { ?item wdt:P364 ?lang. }
                  OPTIONAL { ?item wdt:P136 ?genre. }
                  OPTIONAL { ?item wdt:P2047 ?duration. }
                  OPTIONAL { ?item wdt:P1258 ?rtId. } 

                  OPTIONAL {
                    ?article schema:about ?item .
                    ?article schema:isPartOf <https://en.wikipedia.org/> .
                  }

                  ${scoreQuery}

                  SERVICE wikibase:label { 
                    bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". 
                    ?item rdfs:label ?itemLabel.
                    ?country rdfs:label ?countryLabel.
                    ?lang rdfs:label ?langLabel.
                    ?genre rdfs:label ?genreLabel.
                  }
                }
                GROUP BY ?item ?article ?minDate
                ORDER BY DESC(?minDate)
                LIMIT 1000
            `;

            try {
                const url = `${ENDPOINT}?query=${encodeURIComponent(sparql)}&format=json`;
                const response = await fetch(url, { headers: { 'Accept': 'application/sparql-results+json' } });
                
                if (!response.ok) throw new Error("Network response error");

                const data = await response.json();
                let results = data.results.bindings;

                if (sortByRT) {
                    results.sort((a, b) => {
                        const scoreA = parseScore(a.score ? a.score.value : "0");
                        const scoreB = parseScore(b.score ? b.score.value : "0");
                        
                        if (scoreA !== scoreB) return scoreB - scoreA;

                        const countA = parseCount(a.count ? a.count.value : "0");
                        const countB = parseCount(b.count ? b.count.value : "0");
                        return countB - countA;
                    });
                }

                if (results.length === 0) {
                    status.innerText = "No movies found.";
                } else {
                    renderTable(results);
                    status.innerText = `Displaying ${results.length} movies.`;
                    btnDownload.style.display = 'inline-block'; // Enable download
                }

            } catch (error) {
                console.error(error);
                status.innerText = "Error: " + error.message;
            } finally {
                btnSearch.disabled = false;
            }
        }

        function parseScore(scoreStr) {
            if (!scoreStr || scoreStr === "-") return -1;
            if (scoreStr.includes('%')) {
                return parseInt(scoreStr.replace('%', ''));
            } else if (scoreStr.includes('/')) {
                let parts = scoreStr.split('/');
                return (parseFloat(parts[0]) / parseFloat(parts[1])) * 100;
            }
            return 0;
        }

        function parseCount(countStr) {
            const nums = countStr.replace(/[^0-9]/g, '');
            return nums ? parseInt(nums) : 0;
        }

        function renderTable(results) {
            const tbody = document.querySelector("#results-table tbody");
            const seenIds = new Set();

            results.forEach(row => {
                const id = row.item.value;
                if (seenIds.has(id)) return;
                seenIds.add(id);

                // --- DATA PREPARATION ---
                const title = row.title ? row.title.value : "Unknown";
                const date = row.minDate ? row.minDate.value.substring(0, 4) : "-";
                
                let country = row.countries ? row.countries.value : "-";
                country = country.replace("People's Republic of China", "China");

                const lang = row.languages ? row.languages.value : "-";
                
                let genreText = row.genres ? row.genres.value : "-";
                genreText = genreText.replace(/ film/gi, ""); 

                let durationRaw = row.runtime ? Math.round(parseFloat(row.runtime.value)) : "";
                let durationStr = durationRaw ? durationRaw + " min" : "-";

                let scoreStr = "-";
                let reviewCountStr = "";
                let rtUrl = "";

                if (row.score) {
                    scoreStr = row.score.value;
                    const c = row.count ? row.count.value : "";
                    const cleanCount = c.replace(/[^0-9]/g, '');
                    reviewCountStr = cleanCount ? `(${cleanCount})` : "";
                    
                    // URL Fix: P1258 sometimes includes /m/, sometimes not.
                    // But your observation is correct: Wikidata usually stores "/m/movie_name" or just "movie_name"
                    // We check if it starts with 'm/' or not.
                    if (row.rottenId) {
                        let rid = row.rottenId.value;
                        if (!rid.startsWith('/m/')) {
                            // Some IDs might be raw. Safe to prepend if missing, 
                            // BUT Wikidata P1258 guidelines say "ID string".
                            // If your experience says it includes /m, we trust that.
                            // Let's handle both cases just in case dirty data exists.
                             if (!rid.startsWith('m/')) {
                                // It seems P1258 usually stores just the slug "movie_name"
                                // If you saw "/m/" included, we use it as is.
                                // If not, we add /m/. 
                                // Actually, let's stick to your specific instruction: 
                                // "ID itself includes /m". So we just append.
                             }
                        }
                        rtUrl = `https://www.rottentomatoes.com${rid.startsWith('/') ? '' : '/'}${rid}`;
                    }
                }
                
                const wikiLink = row.article ? row.article.value : row.item.value;

                // --- SAVE FOR EXCEL ---
                globalMovieData.push({
                    Title: title,
                    Year: date,
                    Country: country,
                    Language: lang,
                    Genre: genreText,
                    Duration: durationRaw, // Raw number for Excel
                    Tomatometer: scoreStr,
                    ReviewCount: reviewCountStr.replace(/[()]/g, ''), // Raw number
                    WikiLink: wikiLink,
                    RTLink: rtUrl
                });

                // --- RENDER HTML ---
                let scoreHtml = scoreStr;
                if (rtUrl && scoreStr !== "-") {
                    scoreHtml = `<a href="${rtUrl}" target="_blank" class="score-val">${scoreStr}</a>`;
                }
                if (reviewCountStr) {
                    scoreHtml += ` <span class="review-count">${reviewCountStr}</span>`;
                }

                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="col-title"><a href="${wikiLink}" target="_blank">${title}</a></td>
                    <td class="col-year">${date}</td>
                    <td class="col-country">${country}</td>
                    <td class="col-lang">${lang}</td>
                    <td class="col-genre">${genreText}</td>
                    <td class="col-duration">${durationStr}</td>
                    <td class="col-score">${scoreHtml}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function downloadExcel() {
            if (globalMovieData.length === 0) return;

            // 1. Create Worksheet
            const worksheet = XLSX.utils.json_to_sheet(globalMovieData);

            // 2. Add Hyperlinks (The Magic Part)
            // We loop through the data and add link properties to cells
            const range = XLSX.utils.decode_range(worksheet['!ref']);
            
            for (let R = range.s.r + 1; R <= range.e.r; ++R) { // Skip header row
                const rowIndex = R - 1; // Data index
                const rowData = globalMovieData[rowIndex];

                // Link for Title (Column A)
                const cellTitle = XLSX.utils.encode_cell({r: R, c: 0});
                if (rowData.WikiLink) {
                    worksheet[cellTitle].l = { Target: rowData.WikiLink };
                    worksheet[cellTitle].s = { font: { color: { rgb: "0000FF" }, underline: true } }; // Style hint
                }

                // Link for Tomatometer (Column G)
                // Note: Column index depends on object key order. 
                // Keys: Title(0), Year(1), Country(2), Language(3), Genre(4), Duration(5), Tomatometer(6)
                const cellRT = XLSX.utils.encode_cell({r: R, c: 6});
                if (rowData.RTLink) {
                    if (!worksheet[cellRT]) worksheet[cellRT] = { t: 's', v: rowData.Tomatometer }; // Ensure cell exists
                    worksheet[cellRT].l = { Target: rowData.RTLink };
                }
            }

            // 3. Create Workbook and Download
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Movies");
            XLSX.writeFile(workbook, "wikidata_movies.xlsx");
        }
    </script>
</body>
</html>
